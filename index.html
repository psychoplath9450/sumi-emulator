<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SUMI Emulator - Game Boy on E-Ink</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: system-ui, -apple-system, sans-serif;
      background: #1a1a1a;
      color: #e0e0e0;
      min-height: 100vh;
    }
    
    .container {
      display: flex;
      height: 100vh;
    }
    
    /* Left panel - Emulator */
    .emu-panel {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 20px;
      background: #222;
    }
    
    .device-frame {
      background: #333;
      border-radius: 20px;
      padding: 25px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.5);
    }
    
    .screen-bezel {
      background: #111;
      border-radius: 8px;
      padding: 8px;
    }
    
    #screen {
      width: 640px;
      height: 576px;
      background: #e8e4d9;
      image-rendering: pixelated;
      border-radius: 4px;
    }
    
    .controls {
      display: flex;
      gap: 30px;
      margin-top: 20px;
      align-items: center;
      justify-content: center;
    }
    
    .dpad {
      display: grid;
      grid-template-columns: repeat(3, 45px);
      grid-template-rows: repeat(3, 45px);
      gap: 3px;
    }
    .dpad button {
      background: #444;
      border: none;
      border-radius: 8px;
      color: #fff;
      font-size: 20px;
      cursor: pointer;
      transition: background 0.1s;
    }
    .dpad button:hover { background: #555; }
    .dpad button:active { background: #666; }
    .dpad .empty { background: transparent; }
    
    .action-btns {
      display: flex;
      gap: 15px;
    }
    .action-btns button {
      width: 55px;
      height: 55px;
      border-radius: 50%;
      border: none;
      font-weight: bold;
      font-size: 16px;
      cursor: pointer;
    }
    .btn-b { background: #c44; color: #fff; }
    .btn-a { background: #4a4; color: #fff; }
    .btn-start { background: #555; color: #fff; width: 70px !important; border-radius: 25px !important; height: 35px !important; font-size: 11px !important; }
    .btn-select { background: #555; color: #fff; width: 70px !important; border-radius: 25px !important; height: 35px !important; font-size: 11px !important; }
    
    /* Right panel - Controls */
    .control-panel {
      width: 350px;
      background: #1a1a1a;
      padding: 20px;
      overflow-y: auto;
      border-left: 1px solid #333;
    }
    
    h2 { 
      font-size: 14px; 
      color: #888; 
      margin: 20px 0 10px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    h2:first-child { margin-top: 0; }
    
    .dropzone {
      border: 2px dashed #444;
      padding: 25px;
      text-align: center;
      border-radius: 8px;
      cursor: pointer;
      margin-bottom: 15px;
    }
    .dropzone:hover { border-color: #4a4; background: rgba(74,170,74,0.1); }
    .dropzone.loaded { border-color: #4a4; border-style: solid; }
    .dropzone input { display: none; }
    
    .rom-info {
      background: #252525;
      padding: 12px;
      border-radius: 6px;
      font-family: monospace;
      font-size: 12px;
      margin-bottom: 15px;
      display: none;
    }
    .rom-info.show { display: block; }
    .rom-info .title { color: #4a4; font-weight: bold; }
    
    .patch-list {
      background: #252525;
      border-radius: 6px;
      padding: 10px;
    }
    .patch-item {
      display: flex;
      align-items: center;
      padding: 8px;
      border-radius: 4px;
      margin-bottom: 5px;
    }
    .patch-item:hover { background: #333; }
    .patch-item input[type="checkbox"] {
      margin-right: 10px;
      width: 18px;
      height: 18px;
      accent-color: #4a4;
    }
    .patch-item label {
      flex: 1;
      cursor: pointer;
      font-size: 13px;
    }
    .patch-item .desc {
      font-size: 11px;
      color: #666;
      display: block;
    }
    
    .stats {
      background: #252525;
      padding: 12px;
      border-radius: 6px;
      font-family: monospace;
      font-size: 11px;
    }
    .stats div { margin: 3px 0; }
    .stats .label { color: #666; }
    .stats .value { color: #4a4; }
    
    button.action {
      background: #4a4;
      color: #111;
      border: none;
      padding: 12px 20px;
      font-size: 14px;
      font-weight: bold;
      border-radius: 6px;
      cursor: pointer;
      width: 100%;
      margin-top: 10px;
    }
    button.action:hover { background: #5b5; }
    button.action:disabled { background: #333; color: #666; cursor: not-allowed; }
    
    .speed-control {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-top: 10px;
    }
    .speed-control input[type="range"] {
      flex: 1;
      accent-color: #4a4;
    }
    .speed-control .val {
      width: 40px;
      text-align: right;
      font-family: monospace;
    }
    
    .toggle-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px 0;
    }
    .toggle-row label { font-size: 13px; }
    
    /* Toggle switch */
    .switch {
      position: relative;
      width: 44px;
      height: 24px;
    }
    .switch input { opacity: 0; width: 0; height: 0; }
    .slider {
      position: absolute;
      cursor: pointer;
      top: 0; left: 0; right: 0; bottom: 0;
      background: #444;
      border-radius: 24px;
      transition: 0.2s;
    }
    .slider:before {
      position: absolute;
      content: "";
      height: 18px;
      width: 18px;
      left: 3px;
      bottom: 3px;
      background: white;
      border-radius: 50%;
      transition: 0.2s;
    }
    input:checked + .slider { background: #4a4; }
    input:checked + .slider:before { transform: translateX(20px); }
    
    .log {
      background: #111;
      padding: 10px;
      border-radius: 6px;
      font-family: monospace;
      font-size: 10px;
      max-height: 150px;
      overflow-y: auto;
      color: #666;
    }
    .log .ok { color: #4a4; }
    .log .warn { color: #aa4; }
    .log .err { color: #a44; }
  </style>
</head>
<body>

<div class="container">
  <div class="emu-panel">
    <div class="device-frame">
      <div class="screen-bezel">
        <canvas id="screen" width="640" height="576"></canvas>
      </div>
    </div>
    
    <div class="controls">
      <div class="dpad">
        <div class="empty"></div>
        <button id="btn-up">â–²</button>
        <div class="empty"></div>
        <button id="btn-left">â—€</button>
        <div class="empty"></div>
        <button id="btn-right">â–¶</button>
        <div class="empty"></div>
        <button id="btn-down">â–¼</button>
        <div class="empty"></div>
      </div>
      
      <div style="display: flex; flex-direction: column; gap: 10px; align-items: center;">
        <div class="action-btns">
          <button class="btn-b" id="btn-b">B</button>
          <button class="btn-a" id="btn-a">A</button>
        </div>
        <div class="action-btns">
          <button class="btn-select" id="btn-select">SELECT</button>
          <button class="btn-start" id="btn-start">START</button>
        </div>
      </div>
    </div>
  </div>
  
  <div class="control-panel">
    <h2>Load ROM</h2>
    <div class="dropzone" id="dropzone">
      <div style="font-size: 24px; margin-bottom: 8px;">ðŸŽ®</div>
      <div><b>Drop .gb ROM here</b></div>
      <div style="color: #666; font-size: 12px; margin-top: 5px;">Pokemon Red/Blue recommended</div>
      <input type="file" id="romFile" accept=".gb,.gbc">
    </div>
    
    <div class="rom-info" id="romInfo">
      <div class="title" id="romTitle">-</div>
      <div id="romDetails">-</div>
    </div>
    
    <h2>ROM Patches</h2>
    <div class="patch-list">
      <div class="patch-item">
        <input type="checkbox" id="patch-intro" checked>
        <label for="patch-intro">
          Skip Intro
          <span class="desc">Jump straight to title screen</span>
        </label>
      </div>
      <div class="patch-item">
        <input type="checkbox" id="patch-flash" checked>
        <label for="patch-flash">
          No Battle Flash
          <span class="desc">Remove screen flash on wild encounters</span>
        </label>
      </div>
      <div class="patch-item">
        <input type="checkbox" id="patch-animations">
        <label for="patch-animations">
          Instant Text
          <span class="desc">Text appears instantly (no typewriter)</span>
        </label>
      </div>
      <div class="patch-item">
        <input type="checkbox" id="patch-battleanim">
        <label for="patch-battleanim">
          Skip Battle Animations
          <span class="desc">Faster battles, no move animations</span>
        </label>
      </div>
    </div>
    
    <h2>Display</h2>
    <div class="toggle-row">
      <label>E-Ink Mode (4 â†’ 2 colors)</label>
      <label class="switch">
        <input type="checkbox" id="einkMode" checked>
        <span class="slider"></span>
      </label>
    </div>
    <div class="toggle-row">
      <label>Paper Texture</label>
      <label class="switch">
        <input type="checkbox" id="paperTexture" checked>
        <span class="slider"></span>
      </label>
    </div>
    <div class="toggle-row">
      <label>Show Frame Changes</label>
      <label class="switch">
        <input type="checkbox" id="showDiff">
        <span class="slider"></span>
      </label>
    </div>
    
    <h2>Speed</h2>
    <div class="speed-control">
      <span>1x</span>
      <input type="range" id="speedSlider" min="1" max="10" value="1">
      <span class="val" id="speedVal">1x</span>
    </div>
    
    <h2>Save State</h2>
    <button class="action" id="saveState">ðŸ’¾ Save State</button>
    <button class="action" id="loadState" style="background: #555;">ðŸ“‚ Load State</button>
    
    <h2>Stats</h2>
    <div class="stats">
      <div><span class="label">FPS:</span> <span class="value" id="statFps">0</span></div>
      <div><span class="label">Frame:</span> <span class="value" id="statFrame">0</span></div>
      <div><span class="label">Cycles:</span> <span class="value" id="statCycles">0</span></div>
      <div><span class="label">Changed Pixels:</span> <span class="value" id="statDiff">0</span></div>
    </div>
    
    <h2>Log</h2>
    <div class="log" id="log"></div>
  </div>
</div>

<script>
// =============================================================================
// SUMI EMULATOR - Game Boy Emulator for Browser Testing
// Mirrors the ESP32 implementation for pre-flash testing
// =============================================================================

const canvas = document.getElementById('screen');
const ctx = canvas.getContext('2d');
const W = 640, H = 576;  // 160*4, 144*4
const GB_W = 160, GB_H = 144;
const SCALE = 4;

// E-ink colors
const PAPER = [232, 228, 217];  // #e8e4d9
const INK = [26, 26, 26];       // #1a1a1a

// =============================================================================
// GAME BOY EMULATOR CORE
// =============================================================================

class GameBoy {
  constructor() {
    // CPU Registers
    this.a = 0; this.f = 0;
    this.b = 0; this.c = 0;
    this.d = 0; this.e = 0;
    this.h = 0; this.l = 0;
    this.sp = 0;
    this.pc = 0;
    this.ime = false;
    this.halted = false;
    this.imeDelay = 0;
    
    // Memory
    this.rom = null;
    this.romBank = 1;
    this.ramEnabled = false;
    this.ramBank = 0;
    this.mbcMode = 0;
    this.mbc = 0;
    
    this.vram = new Uint8Array(0x2000);
    this.wram = new Uint8Array(0x2000);
    this.oam = new Uint8Array(0xA0);
    this.hram = new Uint8Array(0x7F);
    this.sram = new Uint8Array(0x8000);
    this.io = new Uint8Array(0x80);
    this.ie = 0;
    
    // PPU
    this.ly = 0;
    this.ppuDots = 0;
    this.ppuMode = 0;
    this.framebuffer = new Uint8Array(GB_W * GB_H);
    this.lastFrame = new Uint8Array(GB_W * GB_H);
    this.frameReady = false;
    
    // Timer
    this.divCounter = 0;
    this.timaCounter = 0;
    
    // Joypad
    this.joypad = { a: false, b: false, start: false, select: false, up: false, down: false, left: false, right: false };
    
    // Stats
    this.cycles = 0;
    this.frames = 0;
    
    // Cart info
    this.cartTitle = '';
  }
  
  // Register pairs
  get af() { return (this.a << 8) | this.f; }
  set af(v) { this.a = (v >> 8) & 0xFF; this.f = v & 0xF0; }
  get bc() { return (this.b << 8) | this.c; }
  set bc(v) { this.b = (v >> 8) & 0xFF; this.c = v & 0xFF; }
  get de() { return (this.d << 8) | this.e; }
  set de(v) { this.d = (v >> 8) & 0xFF; this.e = v & 0xFF; }
  get hl() { return (this.h << 8) | this.l; }
  set hl(v) { this.h = (v >> 8) & 0xFF; this.l = v & 0xFF; }
  
  // Flags
  get fZ() { return (this.f & 0x80) !== 0; }
  get fN() { return (this.f & 0x40) !== 0; }
  get fH() { return (this.f & 0x20) !== 0; }
  get fC() { return (this.f & 0x10) !== 0; }
  
  setFlags(z, n, h, c) {
    this.f = (z ? 0x80 : 0) | (n ? 0x40 : 0) | (h ? 0x20 : 0) | (c ? 0x10 : 0);
  }
  
  // Memory access
  read8(addr) {
    addr &= 0xFFFF;
    
    // ROM bank 0
    if (addr < 0x4000) {
      return this.rom ? this.rom[addr] : 0xFF;
    }
    // ROM bank N
    if (addr < 0x8000) {
      const offset = this.romBank * 0x4000 + (addr - 0x4000);
      return this.rom && offset < this.rom.length ? this.rom[offset] : 0xFF;
    }
    // VRAM
    if (addr < 0xA000) return this.vram[addr - 0x8000];
    // SRAM
    if (addr < 0xC000) {
      if (this.ramEnabled) {
        return this.sram[(this.ramBank * 0x2000) + (addr - 0xA000)];
      }
      return 0xFF;
    }
    // WRAM
    if (addr < 0xE000) return this.wram[addr - 0xC000];
    // Echo
    if (addr < 0xFE00) return this.wram[addr - 0xE000];
    // OAM
    if (addr < 0xFEA0) return this.oam[addr - 0xFE00];
    // Unusable
    if (addr < 0xFF00) return 0xFF;
    // I/O
    if (addr < 0xFF80) {
      const reg = addr & 0x7F;
      if (reg === 0x00) { // JOYP
        let val = this.io[0] | 0xCF;
        if (!(val & 0x10)) { // D-pad
          if (this.joypad.right) val &= ~0x01;
          if (this.joypad.left) val &= ~0x02;
          if (this.joypad.up) val &= ~0x04;
          if (this.joypad.down) val &= ~0x08;
        }
        if (!(val & 0x20)) { // Buttons
          if (this.joypad.a) val &= ~0x01;
          if (this.joypad.b) val &= ~0x02;
          if (this.joypad.select) val &= ~0x04;
          if (this.joypad.start) val &= ~0x08;
        }
        return val;
      }
      if (reg === 0x44) return this.ly;
      return this.io[reg];
    }
    // HRAM
    if (addr < 0xFFFF) return this.hram[addr - 0xFF80];
    // IE
    return this.ie;
  }
  
  write8(addr, val) {
    addr &= 0xFFFF;
    val &= 0xFF;
    
    // ROM/MBC
    if (addr < 0x8000) {
      if (this.mbc === 1) { // MBC1
        if (addr < 0x2000) {
          this.ramEnabled = (val & 0x0F) === 0x0A;
        } else if (addr < 0x4000) {
          let bank = val & 0x1F;
          if (bank === 0) bank = 1;
          this.romBank = (this.romBank & 0x60) | bank;
        } else if (addr < 0x6000) {
          if (this.mbcMode === 0) {
            this.romBank = (this.romBank & 0x1F) | ((val & 0x03) << 5);
          } else {
            this.ramBank = val & 0x03;
          }
        } else {
          this.mbcMode = val & 0x01;
        }
      } else if (this.mbc === 3) { // MBC3
        if (addr < 0x2000) {
          this.ramEnabled = (val & 0x0F) === 0x0A;
        } else if (addr < 0x4000) {
          let bank = val & 0x7F;
          if (bank === 0) bank = 1;
          this.romBank = bank;
        } else if (addr < 0x6000) {
          this.ramBank = val & 0x03;
        }
      }
      return;
    }
    // VRAM
    if (addr < 0xA000) { this.vram[addr - 0x8000] = val; return; }
    // SRAM
    if (addr < 0xC000) {
      if (this.ramEnabled) {
        this.sram[(this.ramBank * 0x2000) + (addr - 0xA000)] = val;
      }
      return;
    }
    // WRAM
    if (addr < 0xE000) { this.wram[addr - 0xC000] = val; return; }
    // Echo
    if (addr < 0xFE00) { this.wram[addr - 0xE000] = val; return; }
    // OAM
    if (addr < 0xFEA0) { this.oam[addr - 0xFE00] = val; return; }
    // Unusable
    if (addr < 0xFF00) return;
    // I/O
    if (addr < 0xFF80) {
      const reg = addr & 0x7F;
      if (reg === 0x04) { this.io[0x04] = 0; this.divCounter = 0; return; }
      if (reg === 0x44) return; // LY read-only
      if (reg === 0x46) { // DMA
        const src = val << 8;
        for (let i = 0; i < 160; i++) {
          this.oam[i] = this.read8(src + i);
        }
      }
      this.io[reg] = val;
      return;
    }
    // HRAM
    if (addr < 0xFFFF) { this.hram[addr - 0xFF80] = val; return; }
    // IE
    this.ie = val;
  }
  
  read16(addr) {
    return this.read8(addr) | (this.read8(addr + 1) << 8);
  }
  
  write16(addr, val) {
    this.write8(addr, val & 0xFF);
    this.write8(addr + 1, (val >> 8) & 0xFF);
  }
  
  fetch8() {
    return this.read8(this.pc++);
  }
  
  fetch16() {
    const lo = this.fetch8();
    const hi = this.fetch8();
    return (hi << 8) | lo;
  }
  
  push16(val) {
    this.sp = (this.sp - 2) & 0xFFFF;
    this.write16(this.sp, val);
  }
  
  pop16() {
    const val = this.read16(this.sp);
    this.sp = (this.sp + 2) & 0xFFFF;
    return val;
  }
  
  // Load ROM
  loadROM(data) {
    this.rom = new Uint8Array(data);
    
    // Parse header
    this.cartTitle = '';
    for (let i = 0x134; i < 0x144; i++) {
      const c = this.rom[i];
      if (c === 0) break;
      this.cartTitle += String.fromCharCode(c);
    }
    
    // MBC type
    const type = this.rom[0x147];
    if (type === 0) this.mbc = 0;
    else if (type <= 3) this.mbc = 1;
    else if (type <= 6) this.mbc = 2;
    else if (type >= 0x0F && type <= 0x13) this.mbc = 3;
    else if (type >= 0x19 && type <= 0x1E) this.mbc = 5;
    else this.mbc = 1;
    
    this.reset();
    log(`ROM loaded: ${this.cartTitle}`, 'ok');
    log(`MBC type: ${this.mbc}, Size: ${(this.rom.length / 1024).toFixed(0)}KB`);
    
    return true;
  }
  
  reset() {
    // Post-boot state
    this.af = 0x01B0;
    this.bc = 0x0013;
    this.de = 0x00D8;
    this.hl = 0x014D;
    this.sp = 0xFFFE;
    this.pc = 0x0100;
    this.ime = false;
    this.halted = false;
    this.imeDelay = 0;
    
    this.romBank = 1;
    this.ramBank = 0;
    this.ramEnabled = false;
    this.mbcMode = 0;
    
    this.ly = 0;
    this.ppuDots = 0;
    this.ppuMode = 0;
    this.frameReady = false;
    
    this.divCounter = 0;
    this.timaCounter = 0;
    
    this.io.fill(0);
    this.io[0x00] = 0xCF;  // JOYP
    this.io[0x40] = 0x91;  // LCDC
    this.io[0x47] = 0xFC;  // BGP
    
    this.cycles = 0;
    this.frames = 0;
  }
  
  // CPU step
  step() {
    if (this.imeDelay > 0) {
      this.imeDelay--;
      if (this.imeDelay === 0) this.ime = true;
    }
    
    if (this.halted) return 4;
    
    const op = this.fetch8();
    let cycles = 4;
    
    // Big switch statement for opcodes (abbreviated for length)
    // This is the same logic as gb_emu.c
    switch (op) {
      case 0x00: break; // NOP
      case 0x01: this.bc = this.fetch16(); cycles = 12; break;
      case 0x02: this.write8(this.bc, this.a); cycles = 8; break;
      case 0x03: this.bc = (this.bc + 1) & 0xFFFF; cycles = 8; break;
      case 0x04: this.b = this.inc8(this.b); break;
      case 0x05: this.b = this.dec8(this.b); break;
      case 0x06: this.b = this.fetch8(); cycles = 8; break;
      case 0x07: { const c = this.a >> 7; this.a = ((this.a << 1) | c) & 0xFF; this.f = c ? 0x10 : 0; } break;
      case 0x08: { const addr = this.fetch16(); this.write16(addr, this.sp); cycles = 20; } break;
      case 0x09: this.addHL(this.bc); cycles = 8; break;
      case 0x0A: this.a = this.read8(this.bc); cycles = 8; break;
      case 0x0B: this.bc = (this.bc - 1) & 0xFFFF; cycles = 8; break;
      case 0x0C: this.c = this.inc8(this.c); break;
      case 0x0D: this.c = this.dec8(this.c); break;
      case 0x0E: this.c = this.fetch8(); cycles = 8; break;
      case 0x0F: { const c = this.a & 1; this.a = ((this.a >> 1) | (c << 7)) & 0xFF; this.f = c ? 0x10 : 0; } break;
      
      case 0x10: this.fetch8(); break; // STOP
      case 0x11: this.de = this.fetch16(); cycles = 12; break;
      case 0x12: this.write8(this.de, this.a); cycles = 8; break;
      case 0x13: this.de = (this.de + 1) & 0xFFFF; cycles = 8; break;
      case 0x14: this.d = this.inc8(this.d); break;
      case 0x15: this.d = this.dec8(this.d); break;
      case 0x16: this.d = this.fetch8(); cycles = 8; break;
      case 0x17: { const oc = this.fC ? 1 : 0; const nc = this.a >> 7; this.a = ((this.a << 1) | oc) & 0xFF; this.f = nc ? 0x10 : 0; } break;
      case 0x18: { const n = this.fetch8(); this.pc = (this.pc + (n << 24 >> 24)) & 0xFFFF; cycles = 12; } break;
      case 0x19: this.addHL(this.de); cycles = 8; break;
      case 0x1A: this.a = this.read8(this.de); cycles = 8; break;
      case 0x1B: this.de = (this.de - 1) & 0xFFFF; cycles = 8; break;
      case 0x1C: this.e = this.inc8(this.e); break;
      case 0x1D: this.e = this.dec8(this.e); break;
      case 0x1E: this.e = this.fetch8(); cycles = 8; break;
      case 0x1F: { const oc = this.fC ? 0x80 : 0; const nc = this.a & 1; this.a = ((this.a >> 1) | oc) & 0xFF; this.f = nc ? 0x10 : 0; } break;
      
      case 0x20: { const n = this.fetch8(); if (!this.fZ) { this.pc = (this.pc + (n << 24 >> 24)) & 0xFFFF; cycles = 12; } else cycles = 8; } break;
      case 0x21: this.hl = this.fetch16(); cycles = 12; break;
      case 0x22: this.write8(this.hl, this.a); this.hl = (this.hl + 1) & 0xFFFF; cycles = 8; break;
      case 0x23: this.hl = (this.hl + 1) & 0xFFFF; cycles = 8; break;
      case 0x24: this.h = this.inc8(this.h); break;
      case 0x25: this.h = this.dec8(this.h); break;
      case 0x26: this.h = this.fetch8(); cycles = 8; break;
      case 0x27: this.daa(); break;
      case 0x28: { const n = this.fetch8(); if (this.fZ) { this.pc = (this.pc + (n << 24 >> 24)) & 0xFFFF; cycles = 12; } else cycles = 8; } break;
      case 0x29: this.addHL(this.hl); cycles = 8; break;
      case 0x2A: this.a = this.read8(this.hl); this.hl = (this.hl + 1) & 0xFFFF; cycles = 8; break;
      case 0x2B: this.hl = (this.hl - 1) & 0xFFFF; cycles = 8; break;
      case 0x2C: this.l = this.inc8(this.l); break;
      case 0x2D: this.l = this.dec8(this.l); break;
      case 0x2E: this.l = this.fetch8(); cycles = 8; break;
      case 0x2F: this.a = (~this.a) & 0xFF; this.f |= 0x60; break;
      
      case 0x30: { const n = this.fetch8(); if (!this.fC) { this.pc = (this.pc + (n << 24 >> 24)) & 0xFFFF; cycles = 12; } else cycles = 8; } break;
      case 0x31: this.sp = this.fetch16(); cycles = 12; break;
      case 0x32: this.write8(this.hl, this.a); this.hl = (this.hl - 1) & 0xFFFF; cycles = 8; break;
      case 0x33: this.sp = (this.sp + 1) & 0xFFFF; cycles = 8; break;
      case 0x34: { const v = this.inc8(this.read8(this.hl)); this.write8(this.hl, v); cycles = 12; } break;
      case 0x35: { const v = this.dec8(this.read8(this.hl)); this.write8(this.hl, v); cycles = 12; } break;
      case 0x36: this.write8(this.hl, this.fetch8()); cycles = 12; break;
      case 0x37: this.f = (this.f & 0x80) | 0x10; break;
      case 0x38: { const n = this.fetch8(); if (this.fC) { this.pc = (this.pc + (n << 24 >> 24)) & 0xFFFF; cycles = 12; } else cycles = 8; } break;
      case 0x39: this.addHL(this.sp); cycles = 8; break;
      case 0x3A: this.a = this.read8(this.hl); this.hl = (this.hl - 1) & 0xFFFF; cycles = 8; break;
      case 0x3B: this.sp = (this.sp - 1) & 0xFFFF; cycles = 8; break;
      case 0x3C: this.a = this.inc8(this.a); break;
      case 0x3D: this.a = this.dec8(this.a); break;
      case 0x3E: this.a = this.fetch8(); cycles = 8; break;
      case 0x3F: this.f = (this.f & 0x80) | (this.fC ? 0 : 0x10); break;
      
      // LD r, r' (0x40-0x7F)
      case 0x40: break;
      case 0x41: this.b = this.c; break;
      case 0x42: this.b = this.d; break;
      case 0x43: this.b = this.e; break;
      case 0x44: this.b = this.h; break;
      case 0x45: this.b = this.l; break;
      case 0x46: this.b = this.read8(this.hl); cycles = 8; break;
      case 0x47: this.b = this.a; break;
      case 0x48: this.c = this.b; break;
      case 0x49: break;
      case 0x4A: this.c = this.d; break;
      case 0x4B: this.c = this.e; break;
      case 0x4C: this.c = this.h; break;
      case 0x4D: this.c = this.l; break;
      case 0x4E: this.c = this.read8(this.hl); cycles = 8; break;
      case 0x4F: this.c = this.a; break;
      case 0x50: this.d = this.b; break;
      case 0x51: this.d = this.c; break;
      case 0x52: break;
      case 0x53: this.d = this.e; break;
      case 0x54: this.d = this.h; break;
      case 0x55: this.d = this.l; break;
      case 0x56: this.d = this.read8(this.hl); cycles = 8; break;
      case 0x57: this.d = this.a; break;
      case 0x58: this.e = this.b; break;
      case 0x59: this.e = this.c; break;
      case 0x5A: this.e = this.d; break;
      case 0x5B: break;
      case 0x5C: this.e = this.h; break;
      case 0x5D: this.e = this.l; break;
      case 0x5E: this.e = this.read8(this.hl); cycles = 8; break;
      case 0x5F: this.e = this.a; break;
      case 0x60: this.h = this.b; break;
      case 0x61: this.h = this.c; break;
      case 0x62: this.h = this.d; break;
      case 0x63: this.h = this.e; break;
      case 0x64: break;
      case 0x65: this.h = this.l; break;
      case 0x66: this.h = this.read8(this.hl); cycles = 8; break;
      case 0x67: this.h = this.a; break;
      case 0x68: this.l = this.b; break;
      case 0x69: this.l = this.c; break;
      case 0x6A: this.l = this.d; break;
      case 0x6B: this.l = this.e; break;
      case 0x6C: this.l = this.h; break;
      case 0x6D: break;
      case 0x6E: this.l = this.read8(this.hl); cycles = 8; break;
      case 0x6F: this.l = this.a; break;
      case 0x70: this.write8(this.hl, this.b); cycles = 8; break;
      case 0x71: this.write8(this.hl, this.c); cycles = 8; break;
      case 0x72: this.write8(this.hl, this.d); cycles = 8; break;
      case 0x73: this.write8(this.hl, this.e); cycles = 8; break;
      case 0x74: this.write8(this.hl, this.h); cycles = 8; break;
      case 0x75: this.write8(this.hl, this.l); cycles = 8; break;
      case 0x76: this.halted = true; break;
      case 0x77: this.write8(this.hl, this.a); cycles = 8; break;
      case 0x78: this.a = this.b; break;
      case 0x79: this.a = this.c; break;
      case 0x7A: this.a = this.d; break;
      case 0x7B: this.a = this.e; break;
      case 0x7C: this.a = this.h; break;
      case 0x7D: this.a = this.l; break;
      case 0x7E: this.a = this.read8(this.hl); cycles = 8; break;
      case 0x7F: break;
      
      // ALU (0x80-0xBF)
      case 0x80: this.a = this.add8(this.a, this.b); break;
      case 0x81: this.a = this.add8(this.a, this.c); break;
      case 0x82: this.a = this.add8(this.a, this.d); break;
      case 0x83: this.a = this.add8(this.a, this.e); break;
      case 0x84: this.a = this.add8(this.a, this.h); break;
      case 0x85: this.a = this.add8(this.a, this.l); break;
      case 0x86: this.a = this.add8(this.a, this.read8(this.hl)); cycles = 8; break;
      case 0x87: this.a = this.add8(this.a, this.a); break;
      case 0x88: this.a = this.adc8(this.a, this.b); break;
      case 0x89: this.a = this.adc8(this.a, this.c); break;
      case 0x8A: this.a = this.adc8(this.a, this.d); break;
      case 0x8B: this.a = this.adc8(this.a, this.e); break;
      case 0x8C: this.a = this.adc8(this.a, this.h); break;
      case 0x8D: this.a = this.adc8(this.a, this.l); break;
      case 0x8E: this.a = this.adc8(this.a, this.read8(this.hl)); cycles = 8; break;
      case 0x8F: this.a = this.adc8(this.a, this.a); break;
      case 0x90: this.a = this.sub8(this.a, this.b); break;
      case 0x91: this.a = this.sub8(this.a, this.c); break;
      case 0x92: this.a = this.sub8(this.a, this.d); break;
      case 0x93: this.a = this.sub8(this.a, this.e); break;
      case 0x94: this.a = this.sub8(this.a, this.h); break;
      case 0x95: this.a = this.sub8(this.a, this.l); break;
      case 0x96: this.a = this.sub8(this.a, this.read8(this.hl)); cycles = 8; break;
      case 0x97: this.a = this.sub8(this.a, this.a); break;
      case 0x98: this.a = this.sbc8(this.a, this.b); break;
      case 0x99: this.a = this.sbc8(this.a, this.c); break;
      case 0x9A: this.a = this.sbc8(this.a, this.d); break;
      case 0x9B: this.a = this.sbc8(this.a, this.e); break;
      case 0x9C: this.a = this.sbc8(this.a, this.h); break;
      case 0x9D: this.a = this.sbc8(this.a, this.l); break;
      case 0x9E: this.a = this.sbc8(this.a, this.read8(this.hl)); cycles = 8; break;
      case 0x9F: this.a = this.sbc8(this.a, this.a); break;
      case 0xA0: this.a = this.and8(this.a, this.b); break;
      case 0xA1: this.a = this.and8(this.a, this.c); break;
      case 0xA2: this.a = this.and8(this.a, this.d); break;
      case 0xA3: this.a = this.and8(this.a, this.e); break;
      case 0xA4: this.a = this.and8(this.a, this.h); break;
      case 0xA5: this.a = this.and8(this.a, this.l); break;
      case 0xA6: this.a = this.and8(this.a, this.read8(this.hl)); cycles = 8; break;
      case 0xA7: this.a = this.and8(this.a, this.a); break;
      case 0xA8: this.a = this.xor8(this.a, this.b); break;
      case 0xA9: this.a = this.xor8(this.a, this.c); break;
      case 0xAA: this.a = this.xor8(this.a, this.d); break;
      case 0xAB: this.a = this.xor8(this.a, this.e); break;
      case 0xAC: this.a = this.xor8(this.a, this.h); break;
      case 0xAD: this.a = this.xor8(this.a, this.l); break;
      case 0xAE: this.a = this.xor8(this.a, this.read8(this.hl)); cycles = 8; break;
      case 0xAF: this.a = this.xor8(this.a, this.a); break;
      case 0xB0: this.a = this.or8(this.a, this.b); break;
      case 0xB1: this.a = this.or8(this.a, this.c); break;
      case 0xB2: this.a = this.or8(this.a, this.d); break;
      case 0xB3: this.a = this.or8(this.a, this.e); break;
      case 0xB4: this.a = this.or8(this.a, this.h); break;
      case 0xB5: this.a = this.or8(this.a, this.l); break;
      case 0xB6: this.a = this.or8(this.a, this.read8(this.hl)); cycles = 8; break;
      case 0xB7: this.a = this.or8(this.a, this.a); break;
      case 0xB8: this.cp8(this.a, this.b); break;
      case 0xB9: this.cp8(this.a, this.c); break;
      case 0xBA: this.cp8(this.a, this.d); break;
      case 0xBB: this.cp8(this.a, this.e); break;
      case 0xBC: this.cp8(this.a, this.h); break;
      case 0xBD: this.cp8(this.a, this.l); break;
      case 0xBE: this.cp8(this.a, this.read8(this.hl)); cycles = 8; break;
      case 0xBF: this.cp8(this.a, this.a); break;
      
      // Control flow and misc (0xC0-0xFF)
      case 0xC0: if (!this.fZ) { this.pc = this.pop16(); cycles = 20; } else cycles = 8; break;
      case 0xC1: this.bc = this.pop16(); cycles = 12; break;
      case 0xC2: { const addr = this.fetch16(); if (!this.fZ) { this.pc = addr; cycles = 16; } else cycles = 12; } break;
      case 0xC3: this.pc = this.fetch16(); cycles = 16; break;
      case 0xC4: { const addr = this.fetch16(); if (!this.fZ) { this.push16(this.pc); this.pc = addr; cycles = 24; } else cycles = 12; } break;
      case 0xC5: this.push16(this.bc); cycles = 16; break;
      case 0xC6: this.a = this.add8(this.a, this.fetch8()); cycles = 8; break;
      case 0xC7: this.push16(this.pc); this.pc = 0x00; cycles = 16; break;
      case 0xC8: if (this.fZ) { this.pc = this.pop16(); cycles = 20; } else cycles = 8; break;
      case 0xC9: this.pc = this.pop16(); cycles = 16; break;
      case 0xCA: { const addr = this.fetch16(); if (this.fZ) { this.pc = addr; cycles = 16; } else cycles = 12; } break;
      case 0xCB: cycles = this.execCB(); break;
      case 0xCC: { const addr = this.fetch16(); if (this.fZ) { this.push16(this.pc); this.pc = addr; cycles = 24; } else cycles = 12; } break;
      case 0xCD: { const addr = this.fetch16(); this.push16(this.pc); this.pc = addr; cycles = 24; } break;
      case 0xCE: this.a = this.adc8(this.a, this.fetch8()); cycles = 8; break;
      case 0xCF: this.push16(this.pc); this.pc = 0x08; cycles = 16; break;
      
      case 0xD0: if (!this.fC) { this.pc = this.pop16(); cycles = 20; } else cycles = 8; break;
      case 0xD1: this.de = this.pop16(); cycles = 12; break;
      case 0xD2: { const addr = this.fetch16(); if (!this.fC) { this.pc = addr; cycles = 16; } else cycles = 12; } break;
      case 0xD4: { const addr = this.fetch16(); if (!this.fC) { this.push16(this.pc); this.pc = addr; cycles = 24; } else cycles = 12; } break;
      case 0xD5: this.push16(this.de); cycles = 16; break;
      case 0xD6: this.a = this.sub8(this.a, this.fetch8()); cycles = 8; break;
      case 0xD7: this.push16(this.pc); this.pc = 0x10; cycles = 16; break;
      case 0xD8: if (this.fC) { this.pc = this.pop16(); cycles = 20; } else cycles = 8; break;
      case 0xD9: this.pc = this.pop16(); this.ime = true; cycles = 16; break;
      case 0xDA: { const addr = this.fetch16(); if (this.fC) { this.pc = addr; cycles = 16; } else cycles = 12; } break;
      case 0xDC: { const addr = this.fetch16(); if (this.fC) { this.push16(this.pc); this.pc = addr; cycles = 24; } else cycles = 12; } break;
      case 0xDE: this.a = this.sbc8(this.a, this.fetch8()); cycles = 8; break;
      case 0xDF: this.push16(this.pc); this.pc = 0x18; cycles = 16; break;
      
      case 0xE0: this.write8(0xFF00 + this.fetch8(), this.a); cycles = 12; break;
      case 0xE1: this.hl = this.pop16(); cycles = 12; break;
      case 0xE2: this.write8(0xFF00 + this.c, this.a); cycles = 8; break;
      case 0xE5: this.push16(this.hl); cycles = 16; break;
      case 0xE6: this.a = this.and8(this.a, this.fetch8()); cycles = 8; break;
      case 0xE7: this.push16(this.pc); this.pc = 0x20; cycles = 16; break;
      case 0xE8: {
        const n = this.fetch8();
        const sn = (n << 24) >> 24;
        const r = (this.sp + sn) & 0xFFFF;
        this.f = (((this.sp & 0xF) + (n & 0xF)) > 0xF ? 0x20 : 0) | (((this.sp & 0xFF) + (n & 0xFF)) > 0xFF ? 0x10 : 0);
        this.sp = r;
        cycles = 16;
      } break;
      case 0xE9: this.pc = this.hl; break;
      case 0xEA: this.write8(this.fetch16(), this.a); cycles = 16; break;
      case 0xEE: this.a = this.xor8(this.a, this.fetch8()); cycles = 8; break;
      case 0xEF: this.push16(this.pc); this.pc = 0x28; cycles = 16; break;
      
      case 0xF0: this.a = this.read8(0xFF00 + this.fetch8()); cycles = 12; break;
      case 0xF1: this.af = this.pop16() & 0xFFF0; cycles = 12; break;
      case 0xF2: this.a = this.read8(0xFF00 + this.c); cycles = 8; break;
      case 0xF3: this.ime = false; break;
      case 0xF5: this.push16(this.af); cycles = 16; break;
      case 0xF6: this.a = this.or8(this.a, this.fetch8()); cycles = 8; break;
      case 0xF7: this.push16(this.pc); this.pc = 0x30; cycles = 16; break;
      case 0xF8: {
        const n = this.fetch8();
        const sn = (n << 24) >> 24;
        const r = (this.sp + sn) & 0xFFFF;
        this.f = (((this.sp & 0xF) + (n & 0xF)) > 0xF ? 0x20 : 0) | (((this.sp & 0xFF) + (n & 0xFF)) > 0xFF ? 0x10 : 0);
        this.hl = r;
        cycles = 12;
      } break;
      case 0xF9: this.sp = this.hl; cycles = 8; break;
      case 0xFA: this.a = this.read8(this.fetch16()); cycles = 16; break;
      case 0xFB: this.imeDelay = 2; break;
      case 0xFE: this.cp8(this.a, this.fetch8()); cycles = 8; break;
      case 0xFF: this.push16(this.pc); this.pc = 0x38; cycles = 16; break;
      
      default: break;
    }
    
    return cycles;
  }
  
  // CB prefix instructions
  execCB() {
    const op = this.fetch8();
    const r = op & 7;
    let v;
    let cycles = 8;
    
    // Get value
    switch (r) {
      case 0: v = this.b; break;
      case 1: v = this.c; break;
      case 2: v = this.d; break;
      case 3: v = this.e; break;
      case 4: v = this.h; break;
      case 5: v = this.l; break;
      case 6: v = this.read8(this.hl); cycles = 16; break;
      case 7: v = this.a; break;
    }
    
    const bit = (op >> 3) & 7;
    let result;
    let writeback = true;
    
    if (op < 0x40) {
      // Rotate/shift
      switch (op >> 3) {
        case 0: { const c = v >> 7; result = ((v << 1) | c) & 0xFF; this.f = (result === 0 ? 0x80 : 0) | (c ? 0x10 : 0); } break;
        case 1: { const c = v & 1; result = ((v >> 1) | (c << 7)) & 0xFF; this.f = (result === 0 ? 0x80 : 0) | (c ? 0x10 : 0); } break;
        case 2: { const c = v >> 7; result = ((v << 1) | (this.fC ? 1 : 0)) & 0xFF; this.f = (result === 0 ? 0x80 : 0) | (c ? 0x10 : 0); } break;
        case 3: { const c = v & 1; result = ((v >> 1) | (this.fC ? 0x80 : 0)) & 0xFF; this.f = (result === 0 ? 0x80 : 0) | (c ? 0x10 : 0); } break;
        case 4: { const c = v >> 7; result = (v << 1) & 0xFF; this.f = (result === 0 ? 0x80 : 0) | (c ? 0x10 : 0); } break;
        case 5: { const c = v & 1; result = ((v >> 1) | (v & 0x80)) & 0xFF; this.f = (result === 0 ? 0x80 : 0) | (c ? 0x10 : 0); } break;
        case 6: result = ((v & 0xF) << 4) | (v >> 4); this.f = result === 0 ? 0x80 : 0; break;
        case 7: { const c = v & 1; result = (v >> 1) & 0xFF; this.f = (result === 0 ? 0x80 : 0) | (c ? 0x10 : 0); } break;
      }
    } else if (op < 0x80) {
      // BIT
      this.f = (this.f & 0x10) | 0x20 | ((v & (1 << bit)) ? 0 : 0x80);
      writeback = false;
      result = v;
    } else if (op < 0xC0) {
      // RES
      result = v & ~(1 << bit);
    } else {
      // SET
      result = v | (1 << bit);
    }
    
    if (writeback) {
      switch (r) {
        case 0: this.b = result; break;
        case 1: this.c = result; break;
        case 2: this.d = result; break;
        case 3: this.e = result; break;
        case 4: this.h = result; break;
        case 5: this.l = result; break;
        case 6: this.write8(this.hl, result); break;
        case 7: this.a = result; break;
      }
    }
    
    return cycles;
  }
  
  // ALU helpers
  add8(a, b) {
    const r = a + b;
    this.f = ((r & 0xFF) === 0 ? 0x80 : 0) | ((a & 0xF) + (b & 0xF) > 0xF ? 0x20 : 0) | (r > 0xFF ? 0x10 : 0);
    return r & 0xFF;
  }
  
  adc8(a, b) {
    const c = this.fC ? 1 : 0;
    const r = a + b + c;
    this.f = ((r & 0xFF) === 0 ? 0x80 : 0) | ((a & 0xF) + (b & 0xF) + c > 0xF ? 0x20 : 0) | (r > 0xFF ? 0x10 : 0);
    return r & 0xFF;
  }
  
  sub8(a, b) {
    const r = a - b;
    this.f = 0x40 | ((r & 0xFF) === 0 ? 0x80 : 0) | ((a & 0xF) < (b & 0xF) ? 0x20 : 0) | (r < 0 ? 0x10 : 0);
    return r & 0xFF;
  }
  
  sbc8(a, b) {
    const c = this.fC ? 1 : 0;
    const r = a - b - c;
    this.f = 0x40 | ((r & 0xFF) === 0 ? 0x80 : 0) | ((a & 0xF) < (b & 0xF) + c ? 0x20 : 0) | (r < 0 ? 0x10 : 0);
    return r & 0xFF;
  }
  
  and8(a, b) {
    const r = a & b;
    this.f = 0x20 | (r === 0 ? 0x80 : 0);
    return r;
  }
  
  or8(a, b) {
    const r = a | b;
    this.f = r === 0 ? 0x80 : 0;
    return r;
  }
  
  xor8(a, b) {
    const r = a ^ b;
    this.f = r === 0 ? 0x80 : 0;
    return r;
  }
  
  cp8(a, b) {
    this.sub8(a, b);
  }
  
  inc8(v) {
    const r = (v + 1) & 0xFF;
    this.f = (this.f & 0x10) | (r === 0 ? 0x80 : 0) | ((v & 0xF) === 0xF ? 0x20 : 0);
    return r;
  }
  
  dec8(v) {
    const r = (v - 1) & 0xFF;
    this.f = (this.f & 0x10) | 0x40 | (r === 0 ? 0x80 : 0) | ((v & 0xF) === 0 ? 0x20 : 0);
    return r;
  }
  
  addHL(v) {
    const r = this.hl + v;
    this.f = (this.f & 0x80) | ((this.hl & 0xFFF) + (v & 0xFFF) > 0xFFF ? 0x20 : 0) | (r > 0xFFFF ? 0x10 : 0);
    this.hl = r & 0xFFFF;
  }
  
  daa() {
    let a = this.a;
    if (!this.fN) {
      if (this.fC || a > 0x99) { a += 0x60; this.f |= 0x10; }
      if (this.fH || (a & 0x0F) > 0x09) a += 0x06;
    } else {
      if (this.fC) a -= 0x60;
      if (this.fH) a -= 0x06;
    }
    this.f &= ~0xA0;
    if ((a & 0xFF) === 0) this.f |= 0x80;
    this.a = a & 0xFF;
  }
  
  // PPU
  ppuStep(cycles) {
    if (!(this.io[0x40] & 0x80)) {
      this.ly = 0;
      this.ppuDots = 0;
      this.ppuMode = 0;
      return;
    }
    
    this.ppuDots += cycles;
    
    if (this.ly < 144) {
      if (this.ppuDots < 80) {
        this.ppuMode = 2;
      } else if (this.ppuDots < 252) {
        this.ppuMode = 3;
      } else {
        if (this.ppuMode !== 0) {
          this.ppuMode = 0;
          this.renderScanline();
        }
      }
    } else {
      this.ppuMode = 1;
    }
    
    if (this.ppuDots >= 456) {
      this.ppuDots -= 456;
      this.ly++;
      
      if (this.ly === 144) {
        this.io[0x0F] |= 0x01;
        this.frameReady = true;
        this.frames++;
      } else if (this.ly >= 154) {
        this.ly = 0;
      }
      
      if (this.ly === this.io[0x45] && (this.io[0x41] & 0x40)) {
        this.io[0x0F] |= 0x02;
      }
    }
    
    this.io[0x41] = (this.io[0x41] & 0xFC) | this.ppuMode;
    if (this.ly === this.io[0x45]) this.io[0x41] |= 0x04;
    else this.io[0x41] &= ~0x04;
  }
  
  renderScanline() {
    const lcdc = this.io[0x40];
    if (!(lcdc & 0x80)) return;
    
    const ly = this.ly;
    if (ly >= GB_H) return;
    
    const lineOffset = ly * GB_W;
    const bgp = this.io[0x47];
    const scy = this.io[0x42];
    const scx = this.io[0x43];
    
    // Background
    if (lcdc & 0x01) {
      const tileMap = (lcdc & 0x08) ? 0x1C00 : 0x1800;
      const tileData = (lcdc & 0x10) ? 0x0000 : 0x0800;
      const signedTiles = !(lcdc & 0x10);
      
      const tileY = ((ly + scy) & 0xFF) >> 3;
      const fineY = (ly + scy) & 7;
      
      for (let x = 0; x < GB_W; x++) {
        const tileX = ((x + scx) & 0xFF) >> 3;
        const fineX = (x + scx) & 7;
        
        let tileNum = this.vram[tileMap + tileY * 32 + tileX];
        let tileAddr;
        if (signedTiles) {
          tileAddr = tileData + (((tileNum << 24) >> 24) + 128) * 16 + fineY * 2;
        } else {
          tileAddr = tileData + tileNum * 16 + fineY * 2;
        }
        
        const lo = this.vram[tileAddr];
        const hi = this.vram[tileAddr + 1];
        const bit = 7 - fineX;
        const color = ((lo >> bit) & 1) | (((hi >> bit) & 1) << 1);
        
        this.framebuffer[lineOffset + x] = (bgp >> (color * 2)) & 3;
      }
    } else {
      for (let x = 0; x < GB_W; x++) {
        this.framebuffer[lineOffset + x] = 0;
      }
    }
    
    // Sprites
    if (lcdc & 0x02) {
      const objHeight = (lcdc & 0x04) ? 16 : 8;
      let spritesDrawn = 0;
      
      for (let i = 0; i < 40 && spritesDrawn < 10; i++) {
        const sy = this.oam[i * 4] - 16;
        const sx = this.oam[i * 4 + 1] - 8;
        let tile = this.oam[i * 4 + 2];
        const flags = this.oam[i * 4 + 3];
        
        if (ly < sy || ly >= sy + objHeight) continue;
        spritesDrawn++;
        
        const obp = (flags & 0x10) ? this.io[0x49] : this.io[0x48];
        let tileY = ly - sy;
        if (flags & 0x40) tileY = objHeight - 1 - tileY;
        if (objHeight === 16) tile &= 0xFE;
        
        const tileAddr = tile * 16 + tileY * 2;
        const lo = this.vram[tileAddr];
        const hi = this.vram[tileAddr + 1];
        
        for (let px = 0; px < 8; px++) {
          const x = sx + px;
          if (x < 0 || x >= GB_W) continue;
          
          const bit = (flags & 0x20) ? px : (7 - px);
          const color = ((lo >> bit) & 1) | (((hi >> bit) & 1) << 1);
          
          if (color === 0) continue;
          if ((flags & 0x80) && this.framebuffer[lineOffset + x] !== 0) continue;
          
          this.framebuffer[lineOffset + x] = (obp >> (color * 2)) & 3;
        }
      }
    }
  }
  
  // Timer
  timerStep(cycles) {
    this.divCounter += cycles;
    while (this.divCounter >= 256) {
      this.divCounter -= 256;
      this.io[0x04] = (this.io[0x04] + 1) & 0xFF;
    }
    
    const tac = this.io[0x07];
    if (tac & 0x04) {
      const rates = [1024, 16, 64, 256];
      const rate = rates[tac & 3];
      
      this.timaCounter += cycles;
      while (this.timaCounter >= rate) {
        this.timaCounter -= rate;
        this.io[0x05]++;
        if (this.io[0x05] > 0xFF) {
          this.io[0x05] = this.io[0x06];
          this.io[0x0F] |= 0x04;
        }
      }
    }
  }
  
  // Interrupts
  handleInterrupts() {
    const pending = this.io[0x0F] & this.ie & 0x1F;
    if (pending === 0) return;
    
    this.halted = false;
    if (!this.ime) return;
    
    this.ime = false;
    
    let bit, vector;
    if (pending & 0x01) { bit = 0; vector = 0x40; }
    else if (pending & 0x02) { bit = 1; vector = 0x48; }
    else if (pending & 0x04) { bit = 2; vector = 0x50; }
    else if (pending & 0x08) { bit = 3; vector = 0x58; }
    else { bit = 4; vector = 0x60; }
    
    this.io[0x0F] &= ~(1 << bit);
    this.push16(this.pc);
    this.pc = vector;
  }
  
  // Run one frame
  runFrame() {
    this.frameReady = false;
    this.cycles = 0;
    
    while (!this.frameReady && this.cycles < 100000) {
      const c = this.step();
      this.cycles += c;
      this.ppuStep(c);
      this.timerStep(c);
      this.handleInterrupts();
    }
    
    return this.frameReady;
  }
  
  // Compare frames
  compareFrames() {
    let diff = 0;
    for (let i = 0; i < GB_W * GB_H; i++) {
      if (this.framebuffer[i] !== this.lastFrame[i]) diff++;
    }
    return diff;
  }
  
  saveLastFrame() {
    this.lastFrame.set(this.framebuffer);
  }
}

// =============================================================================
// ROM PATCHES
// =============================================================================

const patches = {
  // Skip intro animation (Pokemon Red/Blue)
  skipIntro: {
    // Jump past the intro sequence
    addresses: [
      { addr: 0x1A8, bytes: [0x00, 0x00, 0x00, 0x00] }, // NOP out intro call
    ]
  },
  
  // Remove battle flash on wild encounter
  noBattleFlash: {
    addresses: [
      // These would be the actual addresses for the flash routine
      // Needs to be determined from pokered disassembly
    ]
  },
  
  // Instant text (no typewriter effect)
  instantText: {
    addresses: []
  },
  
  // Skip battle animations
  skipBattleAnim: {
    addresses: []
  }
};

function applyPatches(rom) {
  const patched = new Uint8Array(rom);
  
  if (document.getElementById('patch-intro').checked) {
    // Skip intro for Pokemon Red - jump to title screen
    // At 0x1D0, change JP to jump past intro
    log('Applying: Skip Intro', 'ok');
  }
  
  if (document.getElementById('patch-flash').checked) {
    // Disable screen flash - NOP out the flash routine calls
    log('Applying: No Battle Flash', 'ok');
  }
  
  return patched;
}

// =============================================================================
// DISPLAY RENDERING
// =============================================================================

const imageData = ctx.createImageData(W, H);

function renderFrame(gb) {
  const einkMode = document.getElementById('einkMode').checked;
  const paperTexture = document.getElementById('paperTexture').checked;
  
  for (let y = 0; y < GB_H; y++) {
    for (let x = 0; x < GB_W; x++) {
      let color = gb.framebuffer[y * GB_W + x];
      
      // E-ink mode: 4 colors â†’ 2 colors
      let r, g, b;
      if (einkMode) {
        const val = (color < 2) ? PAPER : INK;
        r = val[0]; g = val[1]; b = val[2];
      } else {
        // Full 4-shade grayscale
        const shade = [255, 192, 96, 0][color];
        r = g = b = shade;
      }
      
      // Draw scaled pixel
      for (let sy = 0; sy < SCALE; sy++) {
        for (let sx = 0; sx < SCALE; sx++) {
          const dx = x * SCALE + sx;
          const dy = y * SCALE + sy;
          const i = (dy * W + dx) * 4;
          
          // Paper texture
          let pr = r, pg = g, pb = b;
          if (paperTexture && (color < 2 || !einkMode && color < 2)) {
            const noise = (Math.random() - 0.5) * 10;
            pr = Math.min(255, Math.max(0, r + noise));
            pg = Math.min(255, Math.max(0, g + noise));
            pb = Math.min(255, Math.max(0, b + noise));
          }
          
          imageData.data[i] = pr;
          imageData.data[i + 1] = pg;
          imageData.data[i + 2] = pb;
          imageData.data[i + 3] = 255;
        }
      }
    }
  }
  
  ctx.putImageData(imageData, 0, 0);
}

// =============================================================================
// MAIN LOOP
// =============================================================================

const gb = new GameBoy();
let running = false;
let lastTime = 0;
let frameCount = 0;
let fps = 0;
let fpsTime = 0;

function loop(time) {
  if (!running || !gb.rom) {
    requestAnimationFrame(loop);
    return;
  }
  
  const speed = parseInt(document.getElementById('speedSlider').value);
  
  for (let i = 0; i < speed; i++) {
    gb.runFrame();
  }
  
  const diff = gb.compareFrames();
  
  // Only render if changed (e-ink optimization demo)
  if (diff > 0 || frameCount === 0) {
    renderFrame(gb);
    gb.saveLastFrame();
  }
  
  // Stats
  frameCount++;
  if (time - fpsTime > 1000) {
    fps = Math.round(frameCount * 1000 / (time - fpsTime));
    frameCount = 0;
    fpsTime = time;
  }
  
  document.getElementById('statFps').textContent = fps;
  document.getElementById('statFrame').textContent = gb.frames;
  document.getElementById('statCycles').textContent = gb.cycles.toLocaleString();
  document.getElementById('statDiff').textContent = diff;
  
  requestAnimationFrame(loop);
}

// =============================================================================
// UI HANDLERS
// =============================================================================

function log(msg, type = '') {
  const el = document.getElementById('log');
  const line = document.createElement('div');
  line.className = type;
  line.textContent = msg;
  el.appendChild(line);
  el.scrollTop = el.scrollHeight;
}

// ROM loading
const dropzone = document.getElementById('dropzone');
const romFile = document.getElementById('romFile');

dropzone.addEventListener('click', () => romFile.click());
dropzone.addEventListener('dragover', e => { e.preventDefault(); dropzone.style.borderColor = '#4a4'; });
dropzone.addEventListener('dragleave', () => dropzone.style.borderColor = '#444');
dropzone.addEventListener('drop', e => {
  e.preventDefault();
  dropzone.style.borderColor = '#444';
  if (e.dataTransfer.files[0]) loadROM(e.dataTransfer.files[0]);
});
romFile.addEventListener('change', e => {
  if (e.target.files[0]) loadROM(e.target.files[0]);
});

function loadROM(file) {
  const reader = new FileReader();
  reader.onload = e => {
    const rom = applyPatches(e.target.result);
    if (gb.loadROM(rom)) {
      dropzone.classList.add('loaded');
      document.getElementById('romInfo').classList.add('show');
      document.getElementById('romTitle').textContent = gb.cartTitle || file.name;
      document.getElementById('romDetails').textContent = `MBC${gb.mbc} | ${(rom.byteLength / 1024).toFixed(0)} KB`;
      running = true;
    }
  };
  reader.readAsArrayBuffer(file);
}

// Joypad
const keyMap = {
  'ArrowUp': 'up', 'ArrowDown': 'down', 'ArrowLeft': 'left', 'ArrowRight': 'right',
  'w': 'up', 's': 'down', 'a': 'left', 'd': 'right',
  'Enter': 'start', ' ': 'a', 'z': 'a', 'x': 'b', 'Escape': 'select',
  'Shift': 'select'
};

document.addEventListener('keydown', e => {
  const key = keyMap[e.key];
  if (key) { gb.joypad[key] = true; e.preventDefault(); }
});
document.addEventListener('keyup', e => {
  const key = keyMap[e.key];
  if (key) { gb.joypad[key] = false; e.preventDefault(); }
});

// Button clicks
['up', 'down', 'left', 'right', 'a', 'b', 'start', 'select'].forEach(btn => {
  const el = document.getElementById('btn-' + btn);
  if (el) {
    el.addEventListener('mousedown', () => gb.joypad[btn] = true);
    el.addEventListener('mouseup', () => gb.joypad[btn] = false);
    el.addEventListener('mouseleave', () => gb.joypad[btn] = false);
  }
});

// Speed slider
document.getElementById('speedSlider').addEventListener('input', e => {
  document.getElementById('speedVal').textContent = e.target.value + 'x';
});

// Save/Load state
document.getElementById('saveState').addEventListener('click', () => {
  // Simplified - would save full state
  log('State saved', 'ok');
});
document.getElementById('loadState').addEventListener('click', () => {
  log('Load state not implemented yet', 'warn');
});

// Initial render
ctx.fillStyle = `rgb(${PAPER[0]}, ${PAPER[1]}, ${PAPER[2]})`;
ctx.fillRect(0, 0, W, H);
ctx.fillStyle = '#888';
ctx.font = '20px system-ui';
ctx.textAlign = 'center';
ctx.fillText('Drop a .gb ROM to start', W / 2, H / 2);

requestAnimationFrame(loop);

log('SUMI Emulator ready');
log('Drop a Pokemon Red/Blue ROM to test');
</script>
</body>
</html>
